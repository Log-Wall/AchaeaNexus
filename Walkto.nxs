{"name":"walkto","enabled":true,"description":"Denizen Walkto","type":"group","id":1,"items":[{"type":"function","name":"onLoad","enabled":true,"id":2,"code":"run_function('walktoCreate', {}, 'Walkto');"},{"type":"function","name":"onGMCP","enabled":false,"id":15,"code":"if(args.gmcp_method == 'Char.Items.List')\n    GMCP.Char.Items.List = args.gmcp_args;\n\nif(args.gmcp_method == 'Room.Info')\n    GMCP.Room.Info = args.gmcp_args;"},{"type":"function","name":"walktoCreate","enabled":true,"id":5,"code":"walkto = {\n\tpageBreak: 3,\n    pageIndex: 0,\n    displayCap: {}, \n    displayClick: \"\",\n    displayEntries: {}\n}\nGMCP.Char={Items:{List:{}}}\nGMCP.Room={Info:{}}\n\nif(typeof get_variable(\"walktoDB\") != 'undefined' && get_variable(\"walktoDB\").length)\n\twalkto.entries = get_variable(\"walktoDB\"); \nelse\n    walkto.entries = [];\n\nwalkto.save = function() {\n    set_variable(\"walktoDB\",walkto.entries);\n}\n\n//snippet from Zahan's Scog\nwalkto.download_file = function (filename, text) {\n    let element = document.createElement('a');\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n    element.setAttribute('download', filename);\n    element.style.display = 'none';\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n    return true;\n}\n\nwalkto.notice = function(txt) {\n\tlet msg = $('<span></span>', {class:\"mono\"});\n    $('<span></span>',{style:'color:DodgerBlue'}).text('[- ').appendTo(msg);\n    $('<span></span>',{style:'color:OrangeRed'}).text('WALKTO').appendTo(msg);\n    $('<span></span>',{style:'color:DodgerBlue'}).text(' -] ').appendTo(msg);\n    $('<span></span>',{style:'color:GoldenRod'}).text(txt).appendTo(msg)\n    \n    print(msg[0].outerHTML);\n}\n\nwalkto.addEntry = function(obj) {\n    if (!obj.id) {\n        walkto.notice('Attempted to add an invalid entry');\n        return;\n    }\n    \n    if (typeof walkto.entries.find(x => x.id == obj.id) === 'undefined') {\n    \twalkto.entries.push(obj);\n        walkto.notice(`Entry added for ${obj.name}`);\n        walkto.save();\n    }\n    else\n        walkto.notice(`There is already an entry for ${obj.id} - ${obj.name}.`);\n}\n\nwalkto.removeEntry = function(obj) {\n    let entryPos = walkto.entries.findIndex(x => x.id == obj.id);\n    \n    if (entryPos>=0) {\n    \tlet rem = walkto.entries.splice(entryPos, 1);\n        walkto.notice(`Removed Walkto for ${rem[0].name} (${rem[0].id}) in ${rem[0].area}`);\n        walkto.save();\n    }\n    else\n        walkto.notice('Attempted to remove an entry that does not exist.');\n}\n\nwalkto.pathTrack = function(obj) {\n    walkto.notice(`Walking to ${obj.name}`);\n    send_direct(`PATH TRACK ${obj.room}`);\n}\n\nwalkto.displayTable = function() {\n    let entries = walkto.displayEntries;\n    let caption = walkto.displayCap;\n    let click = walkto.displayClick;\n    \n    let tab = $(\"<table></table>\", {class:\"mono\", style:\"max-width:60%\"});\n    if (walkto.pageIndex == 0) {\n        let cap = $(\"<caption></caption>\", {style:\"text-align:left\"}).appendTo(tab);\n        $('<span></span>',{style:'color:DodgerBlue'}).text('[- ').appendTo(cap);\n        $('<span></span>',{style:'color:OrangeRed'}).text('WALKTO').appendTo(cap);\n        $('<span></span>',{style:'color:DodgerBlue'}).text(' -] ').appendTo(cap);\n        $('<span></span>',{style:'color:GoldenRod'}).text('Select a Denizen to ').appendTo(cap)\n        caption.appendTo(cap);\n    \n        let header = $(\"<tr></tr>\", {style: \"text-align:left;color:Ivory\"}).appendTo(tab);\n        $(\"<th></th>\", {style:'width:2em'}).text('').appendTo(header);\n        $(\"<th></th>\", {style:'width:5em'}).text('ID').appendTo(header);\n        $(\"<th></th>\", {style:'width:auto'}).text('Name').appendTo(header);\n        $(\"<th></th>\", {style:'width:auto'}).text('Area').appendTo(header);\n        $(\"<th></th>\", {style:'width:5em'}).text('Room').appendTo(header);\n\t}\n    else {\n        let header = $(\"<tr></tr>\", {style: \"text-align:left;color:Ivory\"}).appendTo(tab);\n        $(\"<th></th>\", {style:'width:2em'}).text('').appendTo(header);\n        $(\"<th></th>\", {style:'width:5em'}).text('').appendTo(header);\n        $(\"<th></th>\", {style:'width:auto'}).text('').appendTo(header);\n        $(\"<th></th>\", {style:'width:auto'}).text('').appendTo(header);\n        $(\"<th></th>\", {style:'width:5em'}).text('').appendTo(header);\n    }\n    \n    let startIndex = walkto.pageIndex > 0 ? (walkto.pageIndex*walkto.pageBreak) : 0;\n    console.log(startIndex);\n    for(let i = startIndex;i < entries.length && i < startIndex+walkto.pageBreak;i++) {\n    \tlet row  = $(\"<tr></tr>\", {style:'cursor:pointer;color:Ivory;text-decoration:underline;'}).appendTo(tab);\n        if (click!='addEntry')\n        \t$(\"<td></td>\", {style:\"color:red;text-decoration:underline\", onclick: `walkto.removeEntry(${JSON.stringify(entries[i])});`}).text('[X]').appendTo(row);\n        else\n             $(\"<td></td>\").text(\"\").appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entries[i])});`}).text(entries[i].id).appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entries[i])});`}).text(entries[i].name).appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entries[i])});`}).text(entries[i].area).appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entries[i])});`}).text(entries[i].room).appendTo(row);\n    }   \n    \n    print(tab[0].outerHTML);\n\n    \n    \n    let pagination;\n    if(Math.ceil(walkto.entries.length/walkto.pageBreak) > walkto.pageIndex+1) {\n        pagination = $(\"<span></span>\", {style:'color:Goldenrod'}).text(`Displaying ${startIndex+walkto.pageBreak} of ${walkto.displayEntries.length}.`);\n        walkto.pageIndex++;\n        $(\"<span></span>\", {style:'color:Goldenrod'}).text(' Click for ').appendTo(pagination);\n        $('<a></a>', {style:'cursor:pointer;color:Ivory;text-decoration:underline;',onclick:'walkto.displayTable()'}).text('MORE').appendTo(pagination);\n    }\n    else {\n        pagination = $(\"<span></span>\", {style:'color:Goldenrod'}).text(`Displaying ${walkto.displayEntries.length} of ${walkto.displayEntries.length}.`);\n    }\n        \n    print(pagination[0].outerHTML);                                                                                               \n}\n\nwalkto.displayAddTable = function(roomDenizens) {\n    walkto.displayCap = $('<span></span>',{style:'font-weight:bold;color:LawnGreen'}).text('ADD');\n    walkto.displayClick = 'addEntry';\n    walkto.displayEntries = roomDenizens\n    walkto.pageIndex = 0;\n    walkto.displayTable();\t    \n}\n\nwalkto.displayRemoveTable = function() {\n    walkto.displayCap = $('<span></span>',{style:'font-weight:bold;color:Red'}).text('REMOVE');\n    walkto.displayClick = 'removeEntry';\n    walkto.displayEntries = walkto.entries.sort((a,b)=>a.area>b.area);\n    walkto.pageIndex = 0;\n    walkto.displayTable();\t    \n}\n\nwalkto.displayWalktoTable = function(walkEntries) {\n    walkto.displayCap = $('<span></span>',{style:'font-weight:bold;color:White'}).text('WALKTO');\n    walkto.displayClick = 'pathTrack';\n    walkto.displayEntries = walkEntries;\n    walkto.pageIndex = 0;\n    walkto.displayTable();\t    \n}\n\nwalkto.importFile = function(evt) {\n    let file = evt.target.files[0]; \n\n    if (file) {\n        let reader = new FileReader();\n        reader.onload = function(e) { \n            let txt = e.target.result;\n            let importEntries = txt.split(\"|\");\n            for(let x of importEntries) {\n                walkto.addEntry(JSON.parse(x));\n            }\n            walkto.notice('Import of entries complete.');\n        }\n        reader.readAsText(file);\n    } \n    else\n        alert(\"Failed to load file\");\n}"},{"type":"alias","name":"","enabled":true,"id":13,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"run_function('walktoCreate', {}, 'Walkto');\nwalkto.notice('Module loaded.');"}],"text":"dw reload"},{"type":"alias","name":"","enabled":true,"id":4,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Get all denizens in the current room\nlet roomDenizens = GMCP.Char.Items.List.items.filter(x => x.attrib == 'm' || x.attrib == 'mx');\n\n// Remove any denizens that are already in the entries\nif(walkto.entries.length>0) \n\troomDenizens = roomDenizens.filter(x => !walkto.entries.find(y => x.id == y.id))\n\n// Add room number and area to each denizen object\nfor(let denizen of roomDenizens) {\n    denizen.room = GMCP.Room.Info.num;\n    denizen.area = GMCP.Room.Info.area;\n}\n\nwalkto.displayAddTable(roomDenizens);"}],"text":"dw add"},{"type":"alias","name":"","enabled":true,"id":7,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Remove entry if found. If not found, show all entries for 'click' removal.\nif (args[1])\n\twalkto.removeEntry(args[1]);\nelse\n    walkto.displayRemoveTable();"}],"text":"^dw rem(?:\\s)?(\\d+)?$"},{"type":"alias","name":"","enabled":true,"id":6,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"//Walk to a specific denizen id.\nlet numEntries = walkto.entries.filter(x => x.id == args[1]);\n\nif (numEntries.length == 1) {\n    walkto.notice(`Walking to ${numEntries[0].name}`);\n    send_direct(`PATH TRACK ${numEntries[0].room}`);\n}\nelse\n    walkto.notice(`No entry was found for ${args[1]}. Try dw search.`);"}],"text":"^dwalk(?:\\s)?(\\d+)?$"},{"type":"alias","name":"","enabled":true,"id":10,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Walk to a denizen by name. If multiple denizens are found that match the provided name. Present a click list for walking.\nlet test = args[1].toLowerCase().trim();\nlet numEntries = walkto.entries.filter(x => x.name.toLowerCase().includes(test));\nif (numEntries.length == 1) {\n    walkto.notice(`Walking to ${numEntries[0].name}`);\n\tsend_direct(`PATH TRACK ${numEntries[0].room}`);\n}\nelse if (numEntries.length == 0)\n    walkto.notice(`No entry was found matching \"${args[1]}\"`);\nelse if (numEntries.length > 1)\n    walkto.displayWalktoTable(numEntries);\n    "}],"text":"^dwalk((\\s\\w+)+)$"},{"type":"alias","name":"","enabled":true,"id":8,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Search all entries for matches based on name. Partial matches will also return. Not case-sensitive.\nlet test = args[1].toLowerCase().trim();\nlet numEntries = walkto.entries.filter(x => x.name.toLowerCase().includes(test));\nif (numEntries.length > 0)\n\twalkto.displayWalktoTable(numEntries);\nelse\n    walkto.notice(`No entries were found matching \"${args[1]}\"`);\n    "}],"text":"^dw search((?:\\s\\w+)+)$"},{"type":"alias","name":"","enabled":true,"id":9,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// If no area is provided, check against current area.\nlet area = args[1] ? args[1].toLowerCase() : GMCP.Room.Info.area.toLowerCase();\n\nlet entries = walkto.entries.filter(x => x.area.toLowerCase() == area);\nwalkto.displayWalktoTable(entries);\n    "}],"text":"^dw area(?:\\s)?(\\w+)?$"},{"type":"alias","name":"","enabled":true,"id":12,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// This is used to create custom landmarks in the walkto entries. For places of note that are not specificially tied to a denizen. Or areas where the denizen is aggro you can set a landmark with the denizen name for dw search/dwalk, at a safe adjacent location.\n\nlet landmark = {\n\tid: Math.floor(Math.random() * 1000000) + 10000, //generate a random number for a unique id.\n    name: '(Landmark) ' + args[1].trim(), // Adding '(Landmark)' will allow \"dw search landmark\" to see all personal landmarks set.\n    room: GMCP.Room.Info.num,\n    area: GMCP.Room.Info.area\n}\n\nwalkto.addEntry(landmark);"}],"text":"^dw create((?:\\s\\w+)+)$"},{"type":"alias","name":"","enabled":true,"id":11,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Display table for all entries in every area.\nlet entries = walkto.entries.sort((a,b)=>a.area>b.area?1:((b.area>a.area)?-1:0));\nwalkto.displayWalktoTable(entries);"}],"text":"dw all"},{"type":"alias","name":"","enabled":true,"id":16,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"const now = new Date();\nlet exportEntries = JSON.stringify(walkto.entries[0]) + \"|\";\nfor(let i=1;i<walkto.entries.length-1;i++) {\n    exportEntries += JSON.stringify(walkto.entries[i]) + \"|\";\n}\nexportEntries += JSON.stringify(walkto.entries[walkto.entries.length-1]);\n\nlet fileName = `Walkto_Export-${now.getFullYear()}${now.getMonth()<9?\"0\":\"\"}${now.getMonth()+1}${now.getDate()<9?\"0\":\"\"}${now.getDate()}`;\nwalkto.download_file(fileName,exportEntries);"}],"text":"dw export"},{"type":"alias","name":"","enabled":true,"id":17,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"let main = $(\"<div></div>\", {\n    id: 'walktoImport',\n    class: \"container\",\n});\n\nmain.dialog({\n    title: 'Walkto Importer',\n    close: function() {\n        console.log(\"closing\");\n        $('#'+this.id).parent().remove();\n    }\n});\n\n$('<input></input>', {\n    type:'file',\n    id:'file',\n    name:'file',\n\taccept:'.txt'})\n\t\t.change(walkto.importFile)\n\t\t.appendTo(main);"}],"text":"dw import"}]}
