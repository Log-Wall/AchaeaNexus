{"name":"walkto","enabled":true,"description":"Denizen Walkto","type":"group","id":1,"items":[{"type":"function","name":"onLoad","enabled":true,"id":2,"code":"run_function('walktoCreate', {}, 'Walkto');"},{"type":"function","name":"walktoCreate","enabled":true,"id":5,"code":"walkto = {}\n\nif(get_variable(\"walktoDB\").length)\n\twalkto.entries = get_variable(\"walktoDB\"); \nelse\n    walkto.entries = [];\n\nwalkto.save = function() {\n    set_variable(\"walktoDB\",walkto.entries);\n}\n\nwalkto.notice = function(txt) {\n\tlet msg = $('<span></span>', {class:\"mono\"});\n    $('<span></span>',{style:'color:DodgerBlue'}).text('[- ').appendTo(msg);\n    $('<span></span>',{style:'color:OrangeRed'}).text('WALKTO').appendTo(msg);\n    $('<span></span>',{style:'color:DodgerBlue'}).text(' -] ').appendTo(msg);\n    $('<span></span>',{style:'color:GoldenRod'}).text(txt).appendTo(msg)\n    \n    print(msg[0].outerHTML);\n}\n\nwalkto.addEntry = function(obj) {\n    if (typeof walkto.entries.find(x => x.id == obj.id) === 'undefined') {\n    \twalkto.entries.push(obj);\n        walkto.notice(`Entry added for ${obj.name}`);\n        walkto.save();\n    }\n    else\n        walkto.notice('Attempted to add entry that already exists.');\n}\n\nwalkto.removeEntry = function(obj) {\n    let entryPos = walkto.entries.findIndex(x => x.id == obj.id);\n    \n    if (entryPos) {\n    \tlet rem = walkto.entries.splice(entryPos, 1);\n        walkto.notice(`Removed Walkto for ${rem[0].name} (${rem[0].id}) in ${rem[0].area}`);\n    }\n    else\n        walkto.notice('Attempted to remove an entry that does not exist.');\n}\n\nwalkto.pathTrack = function(obj) {\n    send_direct(`PATH TRACK ${obj.room}`);\n}\n\nwalkto.displayTable = function(entries, caption, click) {\n    let tab = $(\"<table></table>\", {class:\"mono\", style:\"max-width:60%\"});\n    let cap = $(\"<caption></caption>\", {style:\"text-align:left\"}).appendTo(tab);\n    $('<span></span>',{style:'color:DodgerBlue'}).text('[- ').appendTo(cap);\n    $('<span></span>',{style:'color:OrangeRed'}).text('WALKTO').appendTo(cap);\n    $('<span></span>',{style:'color:DodgerBlue'}).text(' -] ').appendTo(cap);\n    $('<span></span>',{style:'color:GoldenRod'}).text('Select a Denizen to ').appendTo(cap)\n    caption.appendTo(cap);\n    let header = $(\"<tr></tr>\", {style: \"text-align:left;color:white\"}).appendTo(tab);\n\t$(\"<th></th>\", {style:'width:2em'}).text('').appendTo(header);\n    $(\"<th></th>\", {style:'width:5em'}).text('ID').appendTo(header);\n    $(\"<th></th>\", {style:'width:20em'}).text('Name').appendTo(header);\n    $(\"<th></th>\", {style:'width:auto'}).text('Area').appendTo(header);\n    $(\"<th></th>\", {style:'width:5em'}).text('Room').appendTo(header);\n\t\n    for(let entry of entries) {\n    \tlet row  = $(\"<tr></tr>\", {style:'cursor:pointer;color:white;text-decoration:underline;'}).appendTo(tab);\n        if (click!='addEntry')\n        \t$(\"<td></td>\", {style:\"color:red;text-decoration:underline\", onclick: `walkto.removeEntry(${JSON.stringify(entry)});`}).text('[X]').appendTo(row);\n        else\n             $(\"<td></td>\").text(\"\").appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entry)});`}).text(entry.id).appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entry)});`}).text(entry.name).appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entry)});`}).text(entry.area).appendTo(row);\n        $(\"<td></td>\", {onclick: `walkto.${click}(${JSON.stringify(entry)});`}).text(entry.room).appendTo(row);\n    }\n    \n    print(tab[0].outerHTML);\n}\n\nwalkto.displayAddTable = function(roomDenizens) {\n    let cap = $('<span></span>',{style:'font-weight:bold;color:LawnGreen'}).text('ADD');\n    let click = 'addEntry';\n    walkto.displayTable(roomDenizens,cap,click);\t    \n}\n\nwalkto.displayRemoveTable = function() {\n    let cap = $('<span></span>',{style:'font-weight:bold;color:Red'}).text('REMOVE');\n    let click = 'removeEntry';\n    let entries = walkto.entries.sort((a,b)=>a.area>b.area);\n    walkto.displayTable(entries,cap,click);\t    \n}\n\nwalkto.displayWalktoTable = function(walkEntries) {\n    let cap = $('<span></span>',{style:'font-weight:bold;color:White'}).text('WALKTO');\n    let click = 'pathTrack';\n    walkto.displayTable(walkEntries,cap,click);\t    \n}"},{"type":"alias","name":"","enabled":true,"id":4,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Get all denizens in the current room\nlet roomDenizens = GMCP.Char.Items.List.items.filter(x => x.attrib == 'm' || x.attrib == 'mx');\n\n// Remove any denizens that are already in the entries\nif(walkto.entries.length>0) \n\troomDenizens = roomDenizens.filter(x => !walkto.entries.find(y => x.id == y.id))\n\n// Add room number and area to each denizen object\nfor(let denizen of roomDenizens) {\n    denizen.room = GMCP.Room.Info.num;\n    denizen.area = GMCP.Room.Info.area;\n}\n\nwalkto.displayAddTable(roomDenizens);"}],"text":"dw add"},{"type":"alias","name":"","enabled":true,"id":7,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Remove entry if found. If not found, show all entries for 'click' removal.\nif (args[1])\n\twalkto.removeEntry(args[1]);\nelse\n    walkto.displayRemoveTable();"}],"text":"^dw rem(?:\\s)?(\\d+)?$"},{"type":"alias","name":"","enabled":true,"id":6,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"//Walk to a specific denizen id.\nlet numEntries = walkto.entries.filter(x => x.id == args[1]);\n\nif (numEntries.length == 1) {\n    walkto.notice(`Walking to ${numEntries[0].name}`);\n    send_direct(`PATH TRACK ${numEntries[0].room}`);\n}\nelse\n    walkto.notice(`No entry was found for ${args[1]}. Try dw search.`);"}],"text":"^dwalk(?:\\s)?(\\d+)?$"},{"type":"alias","name":"","enabled":true,"id":10,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Walk to a denizen by name. If multiple denizens are found that match the provided name. Present a click list for walking.\nlet test = args[1].toLowerCase().trim();\nlet numEntries = walkto.entries.filter(x => x.name.toLowerCase().includes(test));\nif (numEntries.length == 1) {\n    walkto.notice(`Walking to ${numEntries[0].name}`);\n\tsend_direct(`PATH TRACK ${numEntries[0].room}`);\n}\nelse if (numEntries.length == 0)\n    walkto.notice(`No entry was found matching \"${args[1]}\"`);\nelse if (numEntries.length > 1)\n    walkto.displayWalktoTable(numEntries);\n    "}],"text":"^dwalk((\\s\\w+)+)$"},{"type":"alias","name":"","enabled":true,"id":8,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Search all entries for matches based on name. Partial matches will also return. Not case-sensitive.\nlet test = args[1].toLowerCase().trim();\nlet numEntries = walkto.entries.filter(x => x.name.toLowerCase().includes(test));\nif (numEntries.length > 0)\n\twalkto.displayWalktoTable(numEntries);\nelse\n    walkto.notice(`No entries were found matching \"${args[1]}\"`);\n    "}],"text":"^dw search((?:\\s\\w+)+)$"},{"type":"alias","name":"","enabled":true,"id":9,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"run_function('walktoCreate', {}, 'Walkto');\n// If no area is provided, check against current area.\nlet area = args[1] ? args[1].toLowerCase() : GMCP.Room.Info.area.toLowerCase();\n\nlet entries = walkto.entries.filter(x => x.area.toLowerCase() == area);\nwalkto.displayWalktoTable(entries);\n    "}],"text":"^dw area(?:\\s)?(\\w+)?$"},{"type":"alias","name":"","enabled":true,"id":12,"matching":"regexp","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// This is used to create custom landmarks in the walkto entries. For places of note that are not specificially tied to a denizen. Or areas where the denizen is aggro you can set a landmark with the denizen name for dw search/dwalk, at a safe adjacent location.\n\nlet landmark = {\n\tid: Math.floor(Math.random() * 1000000) + 10000, //generate a random number for a unique id.\n    name: '(Landmark) ' + args[1].trim(), // Adding '(Landmark)' will allow \"dw search landmark\" to see all personal landmarks set.\n    room: GMCP.Room.Info.num,\n    area: GMCP.Room.Info.area\n}\n\nwalkto.addEntry(landmark);"}],"text":"^dw create((?:\\s\\w+)+)$"},{"type":"alias","name":"","enabled":true,"id":11,"matching":"exact","whole_words":true,"case_sensitive":true,"prefix_suffix":true,"actions":[{"action":"script","script":"// Display table for all entries in every area.\nlet entries = walkto.entries.sort((a,b)=>a.area>b.area);\nwalkto.displayWalktoTable(entries);"}],"text":"dw all"}]}